/*
 * Name: Kenny Sun
 * Date Submitted: 1/30/2024
 * Lab Section: 003
 * Assignment Name: Lab 2 - Infix to Postfix Conversion
 */

#include <string>
#include <stack>
#include <iostream>
#include <cctype>

using namespace std;

//Function protoypes
bool alignedParenthesis(string[], const int &);
bool isOperator(const string &);
int operatorPrecedence(const string &);
void printStack(stack<string>);

//Converts an infix arithmetic expression into postfix
//The function takes 3 parameters
//First parameter: array of strings for infix expression
//    each string is either an integer number or operator symbol
//Second parameter: number of strings in infix expression
//Third parameter: array of strings for postfix expression
//    generated by function, same format as first parameter
//    assumes that postfix is at least the size of postfix
//Return value: int, number of strings in postfix expression
//    Returns 0 if an error is encountered when converting expression
//    An error occurs with a mismatched parenthesis, e.g. ( ( ) or ( ) ) etc.
//Operator symbols:
// ( : left parenthesis, all operations between this and ")" take place first
// ) : right parenthesis, all op.s back to previous "(" take place first
// * : multiplication, higher precedence - takes place before "+" and "-"
// / : division, higher precedence - takes place before "+" and "-"
// % : remainder, higher precedence - takes place before "+" and "-"
// + : addition, lower precedence - takes place after "*" , "/" , "%"
// - : subtraction, lower precedence - takes place after "*" , "/" , "%"
//The function is not specified to work with any other operator symbols
//Any string in infix may be assumed to be an integer operand if none
// of the above symbols
int infixToPostfix(string infix[], int length, string postfix[])
{
  //Stack of operators and index to add to post fix and keep track of length
  stack<string> operators;
  int postfixIndex = 0;
  
  //Checks if parenthesis are aligned
  if(!alignedParenthesis(infix, length))
    {
      return 0;
    }
  
  //Loops through the entirety of infix
  for(int i = 0; i < length; i ++)
    {
      //Grabs a value of infix
      string value = infix[i];
      //cout << value << endl;
      //If it's a number, add it to the postfix
      if(isdigit(value[0]))
	{
	  postfix[postfixIndex] = value;
	  postfixIndex++;
	}
      //If it's a parenthesis, just push it onto the stack
      else if(value == "(")
	{
	  operators.push(value);
	}
      //If it's an opeartor,
      else if(value == "+" || value == "-" || value == "*" || value == "/" || value == "%")
	{
	  bool exit = false;
	  while(!exit)
	    {
	      //Check if the top of the stack is empty, has a parenthesis at the top, or an operator of lesser precedence at the top
	      //Checks if it's empty first to avoid accessing an empty stack
	      //If any of the 3 conditions above are met, exit the loop
	      if(operators.empty())
		{
		  exit = true;
		}
	      //Parenthesis is second to avoid checking the precedence of a parenthesis
	      else if(operators.top() == "(") 
		{
		  exit = true;
		}
	      else if(operatorPrecedence(operators.top()) < operatorPrecedence(value))
		{
		  exit = true;
		}
	      //Otherwise take the top operator and add it to postfix and keep looping
	      else
		{
		  string addToPostfix = operators.top();
		  operators.pop();
		  postfix[postfixIndex] = addToPostfix;
		  postfixIndex++;
		}
	    }
	  //Push the operator onto the stack after all is said and done
	  operators.push(value);
	}
      //If it's a right parenthesis
      else if(value == ")")
	{
	  //Until the stack hits a left parenthesis, keep popping off the top and adding it to postfix
	  while(operators.top() != "(")
	    {
	      string addToPostfix = operators.top();
	      operators.pop();
	      postfix[postfixIndex] = addToPostfix;
	      postfixIndex++;
	    }
	  //Pop off the final left parenthesis
	  operators.pop();
	}
    }

  //Add the rest of the operators to the stack
  while(!operators.empty())
    {
      string addToPostfix = operators.top();
      operators.pop();
      if(addToPostfix != "(")
	{ 
	  postfix[postfixIndex] = addToPostfix;
	  postfixIndex++;
	}
    }

  //Return the length
  return postfixIndex;
}

/* alignedParenthesis */
//Function to check if the parenthesis of an infix equation are balanced
bool alignedParenthesis(string infix[], const int & length)
{
  int open = 0;
  for(int i = 0; i < length; i ++)
    {
      //The left and rights should balance each other out
      if(infix[i] == "(")
	{
	  open ++;
	}
      else if(infix[i] == ")")
 	{
	  open --;
	}
      //If open is ever negative, there's been more closing parenthesis than opening
      //So ") (" won't balance the int out because it would immediately shut down at a closing
      //without enough opens
      if(open < 0)
	{
	  return false;
	}
    }

  //Returns if open is 0 which means the parenthesis are all balanced
  return open == 0;
}

/* operatorPrecedence */
//Function that returns 1 or 0 depending on the precedence of the input operator
int operatorPrecedence(const string & input)
{
  if(input == "+" || input == "-")
    {
      return 0;
    }
  else
    {
      return 1;
    }
}

/* printStack */
//Function that creates a copy of the input stack and prints it out
//Used for debugging and checking if the stack was being formed correctly
void printStack(stack<string> inputStack)
{
  //Creates a new stack in reverse order of the input stack to print out
  stack<string> printStack;
  while(!inputStack.empty())
    {
      string value = inputStack.top();
      printStack.push(value);
      inputStack.pop();
    }
  //Prints out the stack
  while(!printStack.empty())
    {
      string value = printStack.top();
      cout << value << " ";
      printStack.pop();
    }
  cout << endl;
}
//Main function to test infixToPostfix()
//Should convert 2 + 3 * 4 + ( 5 - 6 + 7 ) * 8
//            to 2 3 4 * + 5 6 - 7 + 8 * +

/*
int main()
{
  
    string infixExp[] = {"2", "+", "3", "*", "4", "+", "(",
                         "5", "-", "6", "+", "7", ")", "*",
                         "8"};
    string postfixExp[15];
    int postfixLength;

    cout << "Infix expression: ";
    for (int i=0; i<15; i++)
    {
        cout << infixExp[i] << " ";
    }
    cout << endl;
    cout << "Length: 15" << endl << endl;

    postfixLength = infixToPostfix(infixExp, 15, postfixExp);

    cout << "Postfix expression: ";
    for (int i=0; i<postfixLength; i++)
    {
        cout << postfixExp[i] << " ";
    }
    cout << endl;
    cout << "Length: " << postfixLength << endl;
    
    return 0;
  
}

*/